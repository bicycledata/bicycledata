{% extends "layout.html" %}
{% set title = device.name %}

{% block section %}
{% with messages = get_flashed_messages() %}
{% if messages %}
<section>
  <h4>Notification</h4>
  <ul class="alt">
    {% for message in messages %}
    <li>{{ message }}</li>
    {% endfor %}
  </ul>
</section>
{% endif %}
{% endwith %}

<section id="banner">
  <div class="content">
    <header>
      {% if device.online %}
      <h1><span class="icon solid fa-server" style="color: green;"></span> <a href="/v2/devices/{{ device.ident }}">{{
          device.name }}</a></h1>
      {% else %}
      <h1><span class="icon solid fa-server" style="color: red;"></span> <a href="/v2/devices/{{ device.ident }}">{{
          device.name }}</a></h1>
      {% endif %}
    </header>
    <table>
      <tr>
        <th>Start</th>
        <td>{{ session.start }}</td>
      </tr>
      <tr>
        <th>End</th>
        <td>{{ session.end }}</td>
      </tr>
      <tr>
        <th>Duration</th>
        <td>{{ session.duration }}</td>
      </tr>
      <tr>
        <th>Distance</th>
        <td>{{ session.distance }}</td>
      </tr>
    </table>

    <section>
      <h2>Data</h2>
      <ul>
        {% for sensor in sensors %}
        <li><a href="/v2/devices/{{ device.ident }}/sessions/{{ session.name }}/sensors/{{ sensor }}"
            class="button icon solid fa-download">{{ sensor }}</a></li>
        {% endfor %}
      </ul>
    </section>

  </div>
  {% if gps_track and gps_track|length > 1 %}
  <div id="map" style="height: 400px; width: 100%; margin-bottom: 1em;"></div>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    var gpsTrack = {{ gps_track| tojson }};
    if (gpsTrack.length > 1) {
      var map = L.map('map');
      var latlngs = gpsTrack.map(function (pt) { return [pt.lat, pt.lon]; });
      var bounds = L.latLngBounds(latlngs);
      map.fitBounds(bounds);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18,
        attribution: '© OpenStreetMap contributors'
      }).addTo(map);

      // PDOP-based color helper (matches PDOP histogram coloring)
      function pdopColor(mid, alpha) {
        alpha = (typeof alpha === 'number') ? alpha : 0.8;
        if (mid < 1.0) return 'rgba(39,174,96,' + alpha + ')';
        if (mid < 2.0) return 'rgba(46,204,113,' + alpha + ')';
        if (mid < 5.0) return 'rgba(241,196,15,' + alpha + ')';
        if (mid < 10.0) return 'rgba(230,126,34,' + alpha + ')';
        if (mid < 20.0) return 'rgba(231,76,60,' + alpha + ')';
        return 'rgba(192,57,43,' + alpha + ')';
      }

      // Draw route as colored segments using PDOP values
      for (var i = 0; i < gpsTrack.length - 1; i++) {
        var a = gpsTrack[i];
        var b = gpsTrack[i + 1];
        var seg = [[a.lat, a.lon], [b.lat, b.lon]];
        var pdopA = (typeof a.pdop !== 'undefined') ? a.pdop : null;
        var pdopB = (typeof b.pdop !== 'undefined') ? b.pdop : null;
        var mid = null;
        if (pdopA !== null && pdopB !== null) mid = (pdopA + pdopB) / 2.0;
        else if (pdopA !== null) mid = pdopA;
        else if (pdopB !== null) mid = pdopB;

        var color = (mid !== null) ? pdopColor(mid, 0.85) : 'blue';
        L.polyline(seg, { color: color, weight: 4 }).addTo(map);
      }

      L.marker(latlngs[0]).addTo(map).bindPopup('Start').openPopup();
      L.marker(latlngs[latlngs.length - 1]).addTo(map).bindPopup('End');
    }
  </script>
  {% else %}
  <span class="image object">
    <img src="{{ device.image }}" alt="" />
  </span>
  {% endif %}
</section>

<!-- Session Info form -->
<section>
  <h2>Session Info</h2>
  <form method="post" action="">
    <div class="row gtr-uniform">
      <div class="col-4 col-12-small">
        <label for="battery_start"><strong>Battery Start (%)</strong></label>
        <input type="number" id="battery_start" name="battery_start" min="0" max="100" step="1"
          value="{{ session_front.battery_start if session_front.battery_start is defined else '' }}" />
      </div>
      <div class="col-4 col-12-small">
        <label for="battery_end"><strong>Battery End (%)</strong></label>
        <input type="number" id="battery_end" name="battery_end" min="0" max="100" step="1"
          value="{{ session_front.battery_end if session_front.battery_end is defined else '' }}" />
      </div>
      <div class="col-4 col-12-small">
        <label for="people_joined"><strong>People Joined</strong></label>
        <input type="number" id="people_joined" name="people_joined" min="0" max="100" step="1"
          value="{{ session_front.people_joined if session_front.people_joined is defined else '' }}" />
      </div>
      <div class="col-12">
        <label for="notes"><strong>Notes</strong></label>
        <textarea id="notes" name="notes" rows="8" style="min-height:220px; width:100%; box-sizing:border-box;"
          placeholder="Enter additional session notes">{{ session_body }}</textarea>
      </div>
      <div class="col-12">
        <ul class="actions">
          <li><button type="submit" class="button primary">Update</button></li>
        </ul>
      </div>
    </div>
  </form>
</section>

{% if button_durations and button_durations|length > 0 %}
<section>
  <h2>Button Press Durations Histogram</h2>
  <canvas id="buttonHistogram" width="600" height="300"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script type="text/javascript">
    // Prepare histogram bins
    var durations = {{ button_durations | tojson | safe }};
    // Define bin size and range
    var binSize = 0.2;
    var maxDuration = Math.max.apply(null, durations);
    var binCount = Math.ceil(maxDuration / binSize);
    var bins = Array(binCount).fill(0);
    durations.forEach(function (d) {
      var idx = Math.min(Math.floor(d / binSize), binCount - 1);
      bins[idx]++;
    });
    var labels = bins.map(function (_, i) { return (i * binSize).toFixed(1) + '-' + ((i + 1) * binSize).toFixed(1) + 's'; });
    var ctx = document.getElementById('buttonHistogram').getContext('2d');
    new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [{
          label: 'Count',
          data: bins,
          backgroundColor: 'rgba(54, 162, 235, 0.5)',
          borderColor: 'rgba(54, 162, 235, 1)',
          borderWidth: 1
        }]
      },
      options: {
        plugins: { legend: { display: false } },
        scales: {
          x: { title: { display: true, text: 'Duration (seconds)' } },
          y: { title: { display: true, text: 'Count' }, beginAtZero: true }
        }
      }
    });
  </script>
</section>
{% endif %}

{% if gps_intervals and gps_intervals|length > 0 %}
<section>
  <h2>GPS Update Interval Histogram</h2>
  <p>Shows distribution of time between GPS updates (seconds).</p>
  <canvas id="gpsIntervalHistogram" width="600" height="300"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script type="text/javascript">
    var intervals = {{ gps_intervals | tojson | safe }};
    // First bin: 0 - 0.5s, subsequent bins: 1s wide (0.5-1.5, 1.5-2.5, ...)
    var firstBinEdge = 0.5;
    var subsequentBinWidth = 1.0;
    var maxVal = intervals.length ? Math.max.apply(null, intervals) : 0;
    var restBins = 0;
    if (maxVal > firstBinEdge) {
      restBins = Math.ceil((maxVal - firstBinEdge) / subsequentBinWidth);
    }
    var binCount = 1 + restBins;
    var bins = Array(binCount).fill(0);
    intervals.forEach(function (v) {
      if (v < firstBinEdge) {
        bins[0]++;
      } else {
        var idx = 1 + Math.floor((v - firstBinEdge) / subsequentBinWidth);
        idx = Math.min(idx, binCount - 1);
        bins[idx]++;
      }
    });
    // Build labels but only for non-empty bins, append counts to labels
    var allLabels = [];
    allLabels.push('0s');
    for (var i = 1; i < binCount; i++) {
      var mid = i * subsequentBinWidth;
      allLabels.push(mid.toFixed(0) + 's');
    }

    var filteredLabels = [];
    var filteredData = [];
    for (var i = 0; i < bins.length; i++) {
      if (bins[i] > 0) {
        filteredLabels.push(allLabels[i] + ' (' + bins[i] + ')');
        filteredData.push(bins[i]);
      }
    }

    var ctx = document.getElementById('gpsIntervalHistogram').getContext('2d');
    new Chart(ctx, {
      type: 'bar',
      data: {
        labels: filteredLabels,
        datasets: [{
          label: 'Count',
          data: filteredData,
          backgroundColor: 'rgba(75, 192, 192, 0.5)',
          borderColor: 'rgba(75, 192, 192, 1)',
          borderWidth: 1
        }]
      },
      options: {
        plugins: { legend: { display: false } },
        scales: {
          x: { title: { display: true, text: 'Interval (seconds)' } },
          y: { title: { display: true, text: 'Count' }, beginAtZero: true }
        }
      }
    });
  </script>
</section>
{% endif %}

{% if gps_pdop and gps_pdop|length > 0 %}
<section>
  <h2>GPS PDOP Histogram</h2>
  <p>Distribution of PDOP values (Position Dilution of Precision).</p>
  <div style="margin-bottom:0.5em;">
    <strong>PDOP quality legend:</strong>
    <span style="display:inline-block; margin-left:0.5em;">
      <span
        style="display:inline-block; width:12px; height:12px; background:rgba(39,174,96,0.8); border:1px solid rgba(39,174,96,1);"></span>
      <small style="margin-left:6px;">&lt; 1.0 — Ideal</small>
    </span>
    <span style="display:inline-block; margin-left:0.8em;">
      <span
        style="display:inline-block; width:12px; height:12px; background:rgba(46,204,113,0.8); border:1px solid rgba(46,204,113,1);"></span>
      <small style="margin-left:6px;">1.0–2.0 — Excellent</small>
    </span>
    <span style="display:inline-block; margin-left:0.8em;">
      <span
        style="display:inline-block; width:12px; height:12px; background:rgba(241,196,15,0.85); border:1px solid rgba(241,196,15,1);"></span>
      <small style="margin-left:6px;">2.0–5.0 — Good / Acceptable</small>
    </span>
    <span style="display:inline-block; margin-left:0.8em;">
      <span
        style="display:inline-block; width:12px; height:12px; background:rgba(230,126,34,0.85); border:1px solid rgba(230,126,34,1);"></span>
      <small style="margin-left:6px;">5.0–10.0 — Moderate / Fair</small>
    </span>
    <span style="display:inline-block; margin-left:0.8em;">
      <span
        style="display:inline-block; width:12px; height:12px; background:rgba(231,76,60,0.9); border:1px solid rgba(231,76,60,1);"></span>
      <small style="margin-left:6px;">10.0–20.0 — Poor</small>
    </span>
    <span style="display:inline-block; margin-left:0.8em;">
      <span
        style="display:inline-block; width:12px; height:12px; background:rgba(192,57,43,0.95); border:1px solid rgba(192,57,43,1);"></span>
      <small style="margin-left:6px;">&gt; 20.0 — Very Poor / Unusable</small>
    </span>
  </div>
  <canvas id="pdopHistogram" width="600" height="300"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script type="text/javascript">
    var pdops = {{ gps_pdop | tojson | safe }};
    // bin size for PDOP (0.1s increments)
    var binSize = 0.4;
    var maxVal = pdops.length ? Math.max.apply(null, pdops) : 0;
    var binCount = Math.max(1, Math.ceil(maxVal / binSize));
    // limit binCount to avoid huge charts
    binCount = Math.min(binCount, 200);
    var bins = Array(binCount).fill(0);
    pdops.forEach(function (v) {
      var idx = Math.min(Math.floor(v / binSize), binCount - 1);
      bins[idx]++;
    });

    // Build human-readable labels for bins
    var allLabels = [];
    for (var i = 0; i < binCount; i++) {
      var start = i * binSize;
      var end = (i + 1) * binSize;
      allLabels.push(start.toFixed(1) + '-' + end.toFixed(1));
    }

    // Filter out empty bins, append counts to labels and pick color per bin midpoint
    var filteredLabels = [];
    var filteredData = [];
    var filteredColors = [];
    function pdopColor(mid, alpha) {
      // Colors chosen to represent quality from ideal (green) to very poor (dark red)
      alpha = (typeof alpha === 'number') ? alpha : 0.8;
      if (mid < 1.0) return 'rgba(39,174,96,' + alpha + ')';        // <1.0 Ideal / Excellent (green)
      if (mid < 2.0) return 'rgba(46,204,113,' + alpha + ')';       // 1.0-2.0 Excellent (light green)
      if (mid < 5.0) return 'rgba(241,196,15,' + alpha + ')';      // 2.0-5.0 Good (yellow)
      if (mid < 10.0) return 'rgba(230,126,34,' + alpha + ')';     // 5.0-10.0 Moderate (orange)
      if (mid < 20.0) return 'rgba(231,76,60,' + alpha + ')';       // 10.0-20.0 Poor (red)
      return 'rgba(192,57,43,' + alpha + ')';                     // >20 Very Poor (dark red)
    }

    for (var i = 0; i < bins.length; i++) {
      if (bins[i] > 0) {
        var start = i * binSize;
        var mid = start + (binSize / 2);
        filteredLabels.push(allLabels[i] + ' (' + bins[i] + ')');
        filteredData.push(bins[i]);
        filteredColors.push(pdopColor(mid, 0.6));
        // border color with full opacity
        if (typeof filteredBorderColors === 'undefined') var filteredBorderColors = [];
        filteredBorderColors.push(pdopColor(mid, 1.0));
      }
    }

    var ctx = document.getElementById('pdopHistogram').getContext('2d');
    new Chart(ctx, {
      type: 'bar',
      data: {
        labels: filteredLabels,
        datasets: [{
          label: 'Count',
          data: filteredData,
          backgroundColor: filteredColors,
          borderColor: (typeof filteredBorderColors !== 'undefined') ? filteredBorderColors : filteredColors,
          borderWidth: 1
        }]
      },
      options: {
        plugins: { legend: { display: false } },
        scales: {
          x: { title: { display: true, text: 'PDOP' } },
          y: { title: { display: true, text: 'Count' }, beginAtZero: true }
        }
      }
    });
  </script>
</section>
{% endif %}

{% if lidar_distance and lidar_distance|length > 0 %}
<section>
  <h2>Lidar Distance Histogram</h2>
  <canvas id="lidarHistogram" width="600" height="300"></canvas>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script type="text/javascript">
    // Prepare histogram bins
    var durations = {{ lidar_distance | tojson | safe }};
    // Define bin size and range
    var binSize = 25.0;
    var maxDuration = 700.0;
    var binCount = Math.ceil(maxDuration / binSize);
    var bins = Array(binCount).fill(0);
    durations.forEach(function (d) {
      var idx = Math.min(Math.floor(d / binSize), binCount - 1);
      bins[idx]++;
    });
    var labels = bins.map(function (_, i) { return (i * binSize).toFixed(1) + '-' + ((i + 1) * binSize).toFixed(1) + 'cm'; });
    var ctx = document.getElementById('lidarHistogram').getContext('2d');
    new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [{
          label: 'Count',
          data: bins,
          backgroundColor: 'rgba(54, 162, 235, 0.5)',
          borderColor: 'rgba(54, 162, 235, 1)',
          borderWidth: 1
        }]
      },
      options: {
        plugins: { legend: { display: false } },
        scales: {
          x: { title: { display: true, text: 'Distance (cm)' } },
          y: { title: { display: true, text: 'Count' }, beginAtZero: true }
        }
      }
    });
  </script>
</section>
{% endif %}

<!-- Config file content -->
<div class="col-6 col-12-small">
  <label for="config"><strong>Config file</strong></label>
  <pre id="config"
    style="background:#f4f4f4; padding:1em; border-radius:4px; max-height:300px; overflow:auto;">{{ config }}</pre>
</div>

{%if log %}
<!-- Log file content -->
<div class="col-6 col-12-small">
  <label for="log"><strong>Log file</strong></label>
  <pre id="log"
    style="background:#f4f4f4; padding:1em; border-radius:4px; max-height:300px; overflow:auto;">{{ log }}</pre>
</div>
{% endif %}

{% endblock %}
